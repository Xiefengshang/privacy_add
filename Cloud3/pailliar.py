import json
import phe
from phe import paillier
from phe.util import base64_to_int
#savekey
global pubkey

def keypair_dump_jwk(pub, priv, date=None):
    """Serializer for public-private keypair, to JWK format."""
    from datetime import datetime
    if date is None:
        date = datetime.now().strftime('%Y-%m-%dT%H:%M:%S')

    rec_pub = {
        'kty': 'DAJ',
        'alg': 'PAI-GN1',
        'key_ops': ['encrypt'],
        'n': phe.util.int_to_base64(pub.n),
        'kid': 'Paillier public key generated by phe on {}'.format(date)
    }

    rec_priv = {
        'kty': 'DAJ',
        'key_ops': ['decrypt'],
        'p': phe.util.int_to_base64(priv.p),
        'q': phe.util.int_to_base64(priv.q),
        'kid': 'Paillier private key generated by phe on {}'.format(date)
    }

    priv_jwk = json.dumps(rec_priv)
    pub_jwk = json.dumps(rec_pub)
    return pub_jwk, priv_jwk

def genkey():
    public_key, private_key = paillier.generate_paillier_keypair()
    ans = keypair_dump_jwk(public_key, private_key)
    with open("pubkey.pub", "w") as F:
        F.write(ans[0] + "\n")
        print("Written public key to {}".format(F.name))
        F.close()
    with open("privkey.pub", "w") as G:
        G.write(ans[1] + "\n")
        print("Written private key to {}".format(G.name))
        G.close()
    print(public_key)
    return
# loadkey
def keypair_load_jwk(pub_jwk, priv_jwk):
    """Deserializer for public-private keypair, from JWK format."""
    rec_pub = json.loads(pub_jwk)
    rec_priv = json.loads(priv_jwk)
    # Do some basic checks
    assert rec_pub['kty'] == "DAJ", "Invalid public key type"
    assert rec_pub['alg'] == "PAI-GN1", "Invalid public key algorithm"
    assert rec_priv['kty'] == "DAJ", "Invalid private key type"
    pub_n = phe.util.base64_to_int(rec_pub['n'])
    pub = paillier.PaillierPublicKey(pub_n)
    priv_p = phe.util.base64_to_int(rec_priv['p'])
    priv_q = phe.util.base64_to_int(rec_priv['q'])
    priv = paillier.PaillierPrivateKey(pub, priv_p, priv_q)
    return pub, priv

def keypair_load_jwk_pub(pub_jwk):
    """Deserializer for public key, from JWK format."""
    rec_pub = json.loads(pub_jwk)
    # Do some basic checks
    assert rec_pub['kty'] == "DAJ", "Invalid public key type"
    assert rec_pub['alg'] == "PAI-GN1", "Invalid public key algorithm"
    pub_n = phe.util.base64_to_int(rec_pub['n'])
    pub = paillier.PaillierPublicKey(pub_n)
    return pub

def load_key():
    with open("./pubkey.pub", "r") as A:
       pub_jwk = A.read()
    A.close()
    with open("./privkey.pub", "r") as B:
       priv_jwk = B.read()
    B.close()
    pubkey, privkey = keypair_load_jwk(pub_jwk, priv_jwk)
    #print(pubkey)
    return pubkey, privkey

def load_key_pub():
    with open("./pubkey.pub", "r") as A:
       pub_jwk = A.read()
    A.close()
    pubkey = keypair_load_jwk_pub(pub_jwk)
    #print(pubkey)
    return pubkey

def savekey(key):
    with open("priv_key.pub", "w") as F:
        F.write(key + "\n")
        print("Written private key to {}".format(F.name))
        F.close()
        return

def enc(message):
    pubkey=load_key_pub()
    print(pubkey)
    encrypted_message = pubkey.encrypt(message)
    #print(paillier.EncryptedNumber(pubkey, ciphertext=base64_to_int(encrypted_message)))
    return envec_dump_json(pubkey, [encrypted_message])


# 解密
def dec_a(message):
    pubkey, privkey = load_key()
    print("message:",message)
    a1, a2 = envec_load_json(message)
    a = privkey.decrypt(a2[0])
    print("成绩为", a)
    return a

def envec_dump_json(pubkey, enc_vals, indent=None):
    """Serializes a vector of encrypted numbers into a simple JSON format."""
    from phe.util import int_to_base64
    R = {}
    R['public_key'] = {
        'n': int_to_base64(pubkey.n),
    }
    R['values'] = [
        (int_to_base64(x.ciphertext()), x.exponent) for x in enc_vals
    ]
    return json.dumps(R, indent=indent)


def envec_load_json(R_json):
    """Deserializes a vector of encrypted numbers."""
    from phe.util import base64_to_int
    R = json.loads(R_json)
    R_pubkey = R['public_key']
    R_values = R['values']

    # deserialized values:
    pubkey_d = paillier.PaillierPublicKey(n=base64_to_int(R_pubkey['n']))
    values_d = [
        paillier.EncryptedNumber(pubkey_d, ciphertext=base64_to_int(v[0]), exponent=int(v[1]))
        for v in R_values
    ]
    return pubkey_d, values_d

if __name__ == '__main__':
    genkey()
    #pubkey, privkey = load_key()